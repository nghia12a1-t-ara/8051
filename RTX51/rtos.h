#ifndef RTOS_H_
#define RTOS_H_
#include <reg51.h>

/**
@author Vinicius Kursancew
@mainpage RTOS

This is a simple RTOS optimized for the 8051 processor. Currently it supports the KeilC51 compiler.
It has the following features:
@li Scheduler with priority levels, using round-robin for tasks of same-priority
@li Suspend/Resume tasks
@li Mutexes
@li Binary Semaphores
@li ~2.5kbyte code footprint with keil level 7 optimizer
@li RAM footprint starting from ~25 bytes iram + ~80 bytes xram, xram grows according to number of tasks and priorities
@li User defined trap for erroneous behavior

Notice that avoiding priority inversion is left to the user since no priority inheritance is currently implemented.

Code size can be reduced by turning on/off features, using the following macros in the rtos.h file will disable each feature:
@code
#define noSUSPEND
#define noMUTEX
#define noSEMAPHORE
#define noPREEMPTION
#define noTRAP
@endcode

The macros @ref STACK_START, @ref MAX_STACK_SIZE, @ref MAX_TASK_COUNT, @ref MAX_PRIORITIES,
@ref MAX_MUTEX_SHARE, @ref MAX_NAME found in rtos.h affect the configuration of the RTOS.

<b>VERY IMPORTANT THINGS BEFORE USING:</b>
@li DO NOT use keil optimizer above level 7 (default is 8), above level 7 it messes up the stack with it's optimizations.
@li Always check if #define STACK_START is configured correctly. It must match the value from the .M51 file generated by keil (look for a line similar to the one below).

@verbatim
IDATA   001FH     0001H     UNIT         ?STACK
          ^^ This is the STACK_SIZE, so use #define STACK_START 0x1f

@endverbatim

@li Another important setting is going to the Target Options dialog on the 'BL51 Misc' tab. On the OVERLAY textbox add:
@verbatim
k_signalto ! *, k_waiton ! *, k_acquire ! *, k_release ! *,
k_yield ! *, k_suspend ! *, k_resume ! *, schedule ! *,
wake_task ! *, timer_isr ! *
@endverbatim
This is important so Keil does not share ram used by those routines
(Keil cannot figure the calltree when you manipulate the stack on the rtos and it guesses it wrong).
On the same list you also should add your tasks entry points using the following format: <tt> * ! task_entry_function </tt>.
As an example, suppose you have something like:
@code
k_create_task(idle, "idl", 0);
k_create_task(task1, "t1", 1);
k_start();
@endcode
the final configuration would look (notice the invertion of * in relation to ! for the tasks:
@verbatim
k_signalto ! *, k_waiton ! *, k_acquire ! *, k_release ! *,
k_yield ! *, k_suspend ! *, k_resume ! *, schedule ! *,
wake_task ! *, timer_isr ! *, * ! idle, * ! task1
@endverbatim

<em>2010, Vinicius Kursancew</em>
*/

/** @addtogroup rtos rtos
 * @{
 * @publicsection
 */
//VERY IMPORTANT: CHECK FOR STACK START EACH TIME CODE IS COMPILED
//VERY IMPORTANT: CHECK FOR STACK START EACH TIME CODE IS COMPILED
/** @brief VERY IMPORTANT Starting value for the SP, the compiler will give you this value.

If set incorrectly the kernel will crash when doing context switch.
*/
#define STACK_START 0x1d
//VERY IMPORTANT: CHECK FOR STACK START EACH TIME CODE IS COMPILED
//VERY IMPORTANT: CHECK FOR STACK START EACH TIME CODE IS COMPILED



///////////VERY IMPORTANT: CHECK FOR STACK START EACH TIME CODE IS COMPILED
//Look in .m51 file generated by keil, search for ?STACK symbol

//!Maximum stack size, the user should estimate this by checking the maximum depth that function calls may go
#define MAX_STACK_SIZE 30 

//! Maximum size of the name for each task, affects ram used
#define MAX_NAME 4 

//! Maximum number of tasks that can be created, affects ram used	and may not be more than 31
#define MAX_TASK_COUNT 4 

//! Maximum number of priorities allowed, affects ram used
#define MAX_PRIORITIES 3 

//!Maximum number of tasks that may share a mutex, affects ram used per mutex
#define MAX_MUTEX_SHARE 3

//Selects what parts of the OS are enabled
//#define noSUSPEND
//#define noMUTEX
//#define noSEMAPHORE
#define noPREEMPTION
#define noTRAP

#define XRAM_t(t, decl) t xdata decl
#define IDATA_t(t, decl) t idata decl
#define XRAM_PTR_t(t, decl) t xdata * decl
#define IDATA_TO_XRAM_PTR_t(t, decl) t xdata * idata decl
#define XRAM_PTR_cast(t,var) (t xdata *)(var)

//Based on number of tasks configure the type that holds ready tasks
#if (MAX_TASK_COUNT > 16)
#define PRIORITY_BITMASK_t(decl) unsigned long idata decl[MAX_PRIORITIES]
#elif (MAX_TASK_COUNT > 8)
#define PRIORITY_BITMASK_t(decl) unsigned short idata decl[MAX_PRIORITIES]
#else
#define PRIORITY_BITMASK_t(decl) unsigned char idata decl[MAX_PRIORITIES]
#endif 

//!Special value that means NULL for a task
#define TASK_NULL 0xFF

//! Macro to configure timer0
#define SETUP_TIMER TL0 = 0xb0;TH0 = 0x3c;TMOD &= 0xF0;TMOD |= 1;ET0 = 1;TR0 = 1;

#ifndef BYTE_T
#define BYTE_T
typedef unsigned char byte_t;
#endif

//!@ingroup internal
extern byte_t idata ea_save;
//!Saves EA and clears, entering a critical region
#define CBEGIN ea_save|=_testbit_(EA); ea_save <<= 1;
//!Restores EA, exiting the critical region
#define CEND ea_save >>= 1; EA=(ea_save&1);

//!structure that represents a generic sync construct (mutex or semaphore)
struct generic_sync {
	byte_t blocked; //!< Whether the structure is blocked or not
	union {
		byte_t array[MAX_MUTEX_SHARE]; //!< Used for mutexes
		byte_t single; //!< Used for semaphores
	} wake_me; //!< Holds task(s) to wake
};

/** Defined as a function pointer to a function of prototype void fun(void);
*/
typedef	void(code *voidf)(void);

void k_start();
char k_task_create( voidf d, const char* name, byte_t prio );

//Task control functions
void k_yield();
void k_suspend(byte_t t); //a TASK_NULL value passed in t means that the caller task will suspend
void k_resume(byte_t t);

//Binary Semaphore functions, may only be shared among 2 tasks, one sender and one receiver
void k_create_semaphore(XRAM_PTR_t(struct generic_sync, sem));
void k_waiton(XRAM_PTR_t(struct generic_sync, sem));
void k_signalto(XRAM_PTR_t(struct generic_sync, sem));

//Mutex functions, mutexes can be shared among many(MAX_MUTEX_SHARE) tasks 
void k_create_mutex(XRAM_PTR_t(struct generic_sync, sem));
void k_acquire(XRAM_PTR_t(struct generic_sync, sem));
void k_release(XRAM_PTR_t(struct generic_sync, sem));

//!User defined trap, called on internal errors.
void k_user_trap(const char* cause);

/** @}*/

#endif

